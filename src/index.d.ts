import {Predicate, strictEqual} from "./comparators";
import {Evaluator, returnValue} from "./evaluators";

declare class PatternMatching<EV, PV, R> {
    private stack: Map<Predicate<PV>, Evaluator<EV, PV, R>>;
    private defaultEvaluator: Evaluator<EV, PV, R>;

    match(comparator: Predicate<PV>|object|any, evaluator: Evaluator<EV, PV, R>|any): this;
    default(evaluator: Evaluator<EV, PV, R>): this;

    exec(value: PV): R;
}

/**
 * Proxy of [[PatternMatching]] generated by [[pattern]]
 */
export interface ProxyPatternMatching<EV, PV, R> extends PatternMatching<EV, PV, R> {
    /**
     * You can end chain call with `exec()` from `pattern(value)`
     *
     * will call [[PatternMatching.exec]] with value from pattern
     *
     * @override `exec(value: Va)`
     */
    exec(): R;

    /**
     * You also can chain call with `()` from `pattern(value)`
     *
     * will call [[PatternMatching.exec]] with value from pattern
     */
    (): R;
}

/**
 * Provide a pattern-matching like syntax with functional fluent chainable api
 *
 * Think `pattern` as `switch` keyword and `match` as `case` keyword but without need to `break` the `switch-case` expression
 *
 * - First `match` param should be a [[Predicate]], if not create a predicate with [[strictEqual]]
 * - Second `match` param should be an [[Evaluator]], if not create an Evaluator with [[returnValue]]
 *
 * @param value
 *
 * @example
 * ```js
 * import pattern from 'pattern-matching';
 *
 * const value = pattern('foo')
 *  .match('bar', Symbol('bar'))
 *  .match('foo', Symbol('foo'))
 *  .default()
 *  .exec(); // value Symbol('foo')
 *
 * TODO: Use of comparators and evaluators
 * const value = pattern({foo: 'bar', baz: 'foz'})
 *  .match({bar: 'foo', foz: 'baz'}, Symbol(`foo: 'bar', baz: 'foz'`))
 *  .match({baz: 'bar'}, Symbol(`baz: 'bar'`))
 *  .match({foo: 'bar'}, Symbol(`foo: 'bar'`))
 *  .default()(); // value Symbol(`foo: 'bar'`)
 *
 * const json = await pattern(await fetch(jsonService))
 *  .match(response => response.status >= 200 && response.status < 300, r => r.json())
 *  .default(r => {
 *      const error = new Error()
 *      error.r = r;
 *
 *      throw error;
 *  });
 */
export default function pattern<EV, PV, R>(value: EV): ProxyPatternMatching<EV, PV, R>;